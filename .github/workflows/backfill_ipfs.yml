name: Wayback Backfill + IPFS

on:
  workflow_dispatch:
    inputs:
      limit:
        description: "Max snapshots to fetch this run"
        required: false
        default: "25"
      rate_limit_seconds:
        description: "Delay between Wayback requests"
        required: false
        default: "1"
      run_pipeline:
        description: "Run full pipeline after backfill"
        required: false
        default: "true"

permissions:
  contents: read

jobs:
  backfill:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Python deps
        shell: bash
        run: |
          python -m pip install --upgrade pip
          if [ -f workers/requirements.txt ]; then
            pip install -r workers/requirements.txt
          else
            pip install pyyaml
          fi

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Rust cache
        uses: Swatinem/rust-cache@v2

      # Cache-based state restore (never fails if empty).
      - name: Restore backfill state cache (optional)
        id: state-cache
        uses: actions/cache@v4
        with:
          path: |
            out/state
            out/artifacts
          key: larue-state-${{ github.run_id }}
          restore-keys: |
            larue-state-

      - name: Ensure state dirs exist
        shell: bash
        run: |
          mkdir -p out/state out/artifacts
          if [ "${{ steps.state-cache.outputs.cache-hit }}" = "true" ]; then
            echo "Restored prior state from cache."
          else
            echo "No prior state cache found (first run). Continuing."
          fi

      - name: Run Wayback backfill
        shell: bash
        run: |
          python workers/collectors/wayback_backfill.py \
            --config config/ci.toml \
            --limit "${{ inputs.limit }}" \
            --rate-limit-seconds "${{ inputs.rate_limit_seconds }}"

      - name: Run weekly pipeline
        if: ${{ inputs.run_pipeline == 'true' }}
        shell: bash
        run: |
          cargo run -p cli -- run-weekly --config config/ci.toml

      - name: Ensure .nojekyll
        shell: bash
        run: |
          mkdir -p out/site
          touch out/site/.nojekyll

      - name: Pin site to IPFS (Pinata)
        id: ipfs
        uses: ipshipyard/ipfs-deploy-action@v1
        with:
          path: out/site
          pinata-api-key: ${{ secrets.PINATA_API_KEY }}
          pinata-secret-api-key: ${{ secrets.PINATA_API_SECRET }}

      - name: Write IPFS metadata
        shell: bash
        run: |
          CID="${{ steps.ipfs.outputs.cid }}"
          if [ -z "${CID}" ]; then
            echo "ERROR: IPFS CID output was empty. Check the 'Pin site to IPFS' step outputs."
            exit 1
          fi
          DATE="$(date -u +%F)"
          echo "Pinned CID: ${CID}"
          printf '{\n  "cid": "%s",\n  "date": "%s",\n  "source": "github_actions_backfill_ipfs"\n}\n' "${CID}" "${DATE}" > out/site/ipfs.json

      # Optional: upload artifacts for human inspection/debug (not required for restore anymore).
      - name: Upload state snapshot artifact
        uses: actions/upload-artifact@v4
        with:
          name: larue-state-snapshot
          path: |
            out/state
            out/artifacts
          retention-days: 14

      - name: Upload IPFS metadata
        uses: actions/upload-artifact@v4
        with:
          name: ipfs-metadata
          path: out/site/ipfs.json
          retention-days: 30
