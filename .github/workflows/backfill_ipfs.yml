name: Wayback Backfill + IPFS

on:
  workflow_dispatch:
    inputs:
      limit:
        description: "Max snapshots to fetch this run"
        required: false
        default: "25"
      rate_limit_seconds:
        description: "Delay between Wayback requests"
        required: false
        default: "1"
      run_pipeline:
        description: "Run full pipeline after backfill"
        required: false
        default: "true"

permissions:
  contents: read

jobs:
  backfill:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Python deps
        shell: bash
        run: |
          python -m pip install --upgrade pip
          if [ -f workers/requirements.txt ]; then
            pip install -r workers/requirements.txt
          else
            pip install pyyaml
          fi

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Rust cache
        uses: Swatinem/rust-cache@v2

      # IMPORTANT: continue-on-error must be a step-level key (and reliably honored).
      - name: Restore prior state artifact (optional)
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: larue-state
          path: .tmp/larue-state

      - name: Restore state directories (if present)
        shell: bash
        run: |
          mkdir -p out/state out/artifacts

          if [ -d ".tmp/larue-state" ] && [ "$(ls -A .tmp/larue-state 2>/dev/null | wc -l)" -gt 0 ]; then
            echo "Found prior larue-state artifact. Restoring..."

            if [ -d ".tmp/larue-state/out/state" ]; then
              cp -R .tmp/larue-state/out/state/* out/state/ || true
            fi

            if [ -d ".tmp/larue-state/out/artifacts" ]; then
              cp -R .tmp/larue-state/out/artifacts/* out/artifacts/ || true
            fi
          else
            echo "No prior larue-state artifact found (first run). Continuing."
          fi

      - name: Run Wayback backfill
        shell: bash
        run: |
          python workers/collectors/wayback_backfill.py \
            --config config/ci.toml \
            --limit "${{ inputs.limit }}" \
            --rate-limit-seconds "${{ inputs.rate_limit_seconds }}"

      - name: Run weekly pipeline
        if: ${{ inputs.run_pipeline == 'true' }}
        shell: bash
        run: |
          cargo run -p cli -- run-weekly --config config/ci.toml

      - name: Ensure .nojekyll
        shell: bash
        run: |
          mkdir -p out/site
          touch out/site/.nojekyll

      - name: Pin site to IPFS (Pinata)
        id: ipfs
        uses: ipshipyard/ipfs-deploy-action@v1
        with:
          path: out/site
          pinata-api-key: ${{ secrets.PINATA_API_KEY }}
          pinata-secret-api-key: ${{ secrets.PINATA_API_SECRET }}

      - name: Write IPFS metadata
        shell: bash
        run: |
          # ipshipyard/ipfs-deploy-action typically outputs `cid`, but if that ever changes
          # we want a clear error rather than silently writing empty metadata.
          CID="${{ steps.ipfs.outputs.cid }}"
          if [ -z "${CID}" ]; then
            echo "ERROR: IPFS CID output was empty. Check the 'Pin site to IPFS' step outputs."
            exit 1
          fi

          DATE="$(date -u +%F)"
          echo "Pinned CID: ${CID}"
          printf '{\n  "cid": "%s",\n  "date": "%s",\n  "source": "github_actions_backfill_ipfs"\n}\n' "${CID}" "${DATE}" > out/site/ipfs.json

      - name: Upload state artifact
        uses: actions/upload-artifact@v4
        with:
          name: larue-state
          path: |
            out/state
            out/artifacts
          retention-days: 30

      - name: Upload IPFS metadata
        uses: actions/upload-artifact@v4
        with:
          name: ipfs-metadata
          path: out/site/ipfs.json
          retention-days: 30

